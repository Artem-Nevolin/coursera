
# Практика по requests
# В этом задании вы научитесь работать с библиотекой requests (
# https://requests.kennethreitz.org/en/master/
# ), а также научитесь работать с API сервиса VK и его документаций, что является достаточно частой задачей разработчика.
#
# Необходимо написать клиент к API VK , который будет считать распределение возрастов друзей для указанного пользователя. То есть на вход подается username или user_id пользователя, на выходе получаем список пар (<возраст>, <количество друзей с таким возрастом>), отсортированный по убыванию по второму ключу (количество друзей) и по возрастанию по первому ключу (возраст). Например:
#
# 1
# [(26, 8), (21, 6), (22, 6), (40, 2), (19, 1), (20, 1)]
# Для выполнения задания необходимо использовать шаблон проекта:
# https://github.com/alexopryshko/coursera_assignment_tmp
#
# Решение должно быть файлом req/friends.py. В этом файле представлен шаблон функции calc_age, реализацию которой нужно написать.
#
# Для этого вам понадобятся два метода API VK:
#
# 1. Метод для получения id пользователя (
# https://vk.com/dev/users.get
# ). Он необходим, так как на вход может подаваться username пользователя. URL запроса к API VK:
# https://api.vk.com/method/users.get
#
# 2. Метод для получения списка друзей пользователя (
# https://vk.com/dev/friends.get
# ). URL запроса к API VK:
# https://api.vk.com/method/friends.get
#
# Для доступа к этим методам вам понадобится  “Сервисный ключ доступа”:
#
# https://vk.com/dev/access_token?f=3.%20%D0%A1%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BD%D1%8B%D0%B9%20%D0%BA%D0%BB%D1%8E%D1%87%20%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0
#
# Получение сервисного ключа:
#
# 1. Создать новое приложение, перейдя по ссылке
# https://vk.com/apps?act=manage
#
# 2. После создания приложения, перейти в раздел “настройки” и скопировать “Сервисный ключ доступа”.
#
# Если нет возможности получить сервисный ключ, то можно использовать уже созданный:
#
# 12
# ACCESS_TOKEN = '17da724517da724517da72458517b8abce117da17da72454d235c274f1a2be5f45ee711'
#
# В итоге запросы будут иметь вид:
#
# – Для получения id пользователя по username или user_id:
#
# https://api.vk.com/method/users.get?v=5.71&access_token=[token]&user_ids=[user_id
# ]
#
# – Для получения списка друзей:
#
# https://api.vk.com/method/friends.get?v=5.71&access_token
# =[token]&user_id=[user_id]&fields=bdate
#
# При решении задания обратите внимание на несколько моментов.
#
# В запросе мы  используем версию  API VK - «5.81».
#
# В запросе получения списка друзей добавлен ключ fields=bdate.  Он необходим для того, чтобы API сразу вернуло пользователей с датами рождения.
#
# При анализе ответа, полученного методом friends.get, можно заметить,  что bdate есть не у всех пользователей и у некоторых в bdate отсутствует год рождения. Поэтому необходимо пропускать этот случай. Примеры возможных значений: "bdate":"6.6", "bdate":"25.8.1993".Для вычисления возраста, необходимо взять текущий год ,  и вычесть из него год рождения пользователя, полученный из API (без учета месяца и числа).
import requests
import json
from datetime import date

# получаю текущий год
current_date = str(date.today())
current_yare = (current_date.split('-'))[0]

# указываю токен из приложения в VC. как сделать читай инструкцию выше
ACCESS_TOKEN = 'd4a9431cd4a9431cd4a9431cc6d7bdccb6dd4a9d4a9431cb024c9205f6e9436f6cffe1a'
def calc_age(uid):

    # формирую набор параметров для запроса. В начале получим значение ID т.к. на вход программы
    # может быть передан как никнайм так и номер ID. Далее в извлекаю номер ID, по которому и
    # будет формироваться запрос
    payload = {'v': 5.81, 'access_token': ACCESS_TOKEN, 'fields': 'bdate', 'user_id': uid}
    r = requests.get('https://api.vk.com/method/users.get', params=payload)
    uid = (r.json()['response'])[0]['id']

    # формирую запрос для получения списка друзей с указанием даты рождения и возвращаю этот список
    payload = {'v': 5.81, 'access_token': ACCESS_TOKEN, 'fields': 'bdate', 'user_id': uid}
    r2 = requests.get('https://api.vk.com/method/friends.get', params=payload)
    return r2


if __name__ == '__main__':
    # вызов функции для чтения данных из VC по ID
    res = calc_age('reigning')
    # создаю список для всех дней рождений
    ages = []
    # пробегаю по всем друзьям
    for i in (res.json()['response']['items']):
        # пробегаю по параметрам каждого друга, чтобы вычленить дату рождения
        for h in i.items():
            # если нахожу ключ, который указавает на дату рождения, то создаю из значения этого ключа
            # список по разделителю ".", чтобы потом проверить, что в списке корректная дата т.е. три элемента
            if h[0] == 'bdate':
                t = h[1].split('.')
                # проверяю на корректность даты т.е. должно быть три элемента и если это так, то отправляю
                # вычисляю возраст друга т.е. текущий год-год рождения и добавляю в список
                if len(t)>2:
                    delta=int(current_yare)-int(t[-1])
                    ages.append(delta)
    # создаю словать для подсчета возрастов и количества друзей
    age_count={}
    # пробегаю по списку со всеми возрастами
    for age in ages:
        # если взятый возраст есть в ключе словаря, то добавлю 1 в значение ключа
        if age in age_count:
            age_count[age]+=1
        # если взятого возраста ещё нет в ключах словоря, то записываю этот возрас со значением 1
        else:
            age_count[age]=1
    # выполняю сортировку в начале по возрасту по убыванию, а потом по количеству друзей по возрастанию

    sorted_counter = sorted(age_count.items(), key=lambda x: (-x[1], x[0]))
    print(sorted_counter)


# описание сортировки
# age_counts.items() возвращает список кортежей, представляющих элементы словаря age_counts. Каждый кортеж содержит пару (возраст, количество), где возраст - это ключ словаря age_counts, а количество - значение.
#
# key=lambda x: (-x[1], x[0]) - это функция-ключ, которая определяет порядок сортировки. Здесь мы используем лямбда-функцию для создания функции-ключа. В этой функции-ключе мы указываем два критерия сортировки:
#
#     -x[1] - первый критерий сортировки. Мы используем отрицательное значение x[1], чтобы сортировка происходила по убыванию количества людей.
#     x[0] - второй критерий сортировки. Если количество людей одинаково, мы сортируем по возрастанию возраста x[0].
#
# Таким образом, сортировка будет выполняться сначала по убыванию количества людей, а затем в случае одинакового количества людей - по возрастанию возраста.
#
# Например, если у нас есть следующие значения age_counts:
#
# yaml
#
# age_counts = {26: 3, 22: 2, 21: 1, 40: 1, 19: 1}
#
# После сортировки мы получим sorted_counts:
#
# css
#
# sorted_counts = [(26, 3), (22, 2), (21, 1), (40, 1), (19, 1)]
#
# Кортежи отсортированы по убыванию количества людей, а при одинаковом количестве людей - по возрастанию возраста.
#
# Надеюсь, это объяснение помогло! Если у вас возникнут дополнительные вопросы, пожалуйста, дайте мне знать.
# User
# почему именно в таком порядке (-x[1], x[0]), а не (x[0], -x[1])
# ChatGPT
#
# Отличный вопрос! Порядок важен, потому что он определяет приоритетность критериев сортировки.
#
# В данном случае, используя (-x[1], x[0]), мы задаем следующий порядок сортировки:
#
#     Сначала, по отрицательному значению x[1] (количество людей). При отрицательном значении происходит сортировка по убыванию количества людей. Если количество людей одинаково, то этот первый критерий не влияет на результат.
#     Если количество людей совпадает, то сортировка происходит по возрастанию x[0] (возраста).
#
# Важно отметить, что порядок сортировки может быть выбран в зависимости от требований конкретной задачи. В данном случае, предполагается, что
# User
# далее
# ChatGPT
#
# в данном случае предполагается, что более важным критерием сортировки является количество людей (x[1]). Поэтому мы устанавливаем его в первую очередь и используем отрицательное значение для сортировки по убыванию. Затем, если количество людей одинаково, мы используем возраст (x[0]) для дополнительной сортировки по возрастанию.
#
# Итак, порядок (-x[1], x[0]) позволяет сначала упорядочить кортежи по убыванию количества людей, а затем в случае одинакового количества людей - по возрастанию возраста.
#
# Если мы изменим порядок на (x[0], -x[1]), это означало бы следующее:
#
#     Сначала, по возрастанию x[0] (возраста).
#
#     Если возраст совпадает, то сортировка происходит по отрицательному значению x[1] (количество людей).
#
# Это привело бы к сортировке в первую очередь по возрасту, а затем при одинаковом возрасте - по убыванию количества людей.
#
# Выбор порядка сортировки зависит от требований и логики конкретной задачи. В данном случае, выбор порядка (-x[1], x[0]) соответствует требованиям задачи о сортировке по убыванию количества людей и по возрастанию возраста внутри одинакового количества людей.
#
# Надеюсь, это помогло! Если у вас возникнут дополнительные вопросы, пожалуйста, дайте мне знать.
# User
#
#

